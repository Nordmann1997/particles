<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <title>Partikkel-Portfolio med Piltast-navigasjon</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: 'Helvetica Neue', sans-serif; overflow: hidden; }
        canvas { position: fixed; top: 0; left: 0; z-index: 1; pointer-events: none; }
        
        #content-container {
            position: relative;
            z-index: 2;
            width: 100%;
        }
        
        .scroll-section {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            height: 300vh;
        }

        .text-reference, .image-reference {
            position: absolute;
            opacity: 0; 
            pointer-events: none;
        }
        
        #image-ref-1 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-1  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }

        #image-ref-2 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
        #text-ref-2  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-3 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-3  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-4 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
        #text-ref-4  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-5 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-5  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-6 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
        #text-ref-6  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }

        #image-ref-7 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-7  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }

        /* Enkel velkomsttekst som overlay */
        #welcome-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            font-size: 36px;
            font-weight: bold;
            transition: opacity 0.5s ease;
        }

        /* Touch indicator */
        #touch-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Enkel overlay som kan skjules -->
    <div id="welcome-overlay">
        Velkommen til min portefølje<br><br>
        Trykk en tast eller swipe for å starte
    </div>

    <!-- Touch indicator -->
    <div id="touch-indicator">
        Swipe opp/ned eller bruk piltastene for å navigere
    </div>

    <canvas id="particle-canvas"></canvas>
    
    <div id="content-container">
        <div class="scroll-section">
            <div id="image-ref-1" class="image-reference"></div> <div id="text-ref-1" class="text-reference"></div>
        </div>
        <div class="scroll-section">
            <div id="image-ref-2" class="image-reference"></div> <div id="text-ref-2" class="text-reference"></div>
        </div>
        <div class="scroll-section">
             <div id="image-ref-3" class="image-reference"></div> <div id="text-ref-3" class="text-reference"></div>
        </div>
        <div class="scroll-section">
             <div id="image-ref-4" class="image-reference"></div> <div id="text-ref-4" class="text-reference"></div>
        </div>
        <div class="scroll-section">
             <div id="image-ref-5" class="image-reference"></div> <div id="text-ref-5" class="text-reference"></div>
        </div>
        <div class="scroll-section">
             <div id="image-ref-6" class="image-reference"></div> <div id="text-ref-6" class="text-reference"></div>
        </div>
        <div class="scroll-section">
             <div id="image-ref-7" class="image-reference"></div> <div id="text-ref-7" class="text-reference"></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollToPlugin.min.js"></script>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.156.1/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const settings = {
            IMAGE_URLS: [ 
                'https://static.vecteezy.com/system/resources/previews/006/911/398/non_2x/rainbow-waves-background-free-vector.jpg',
                'https://jwk.no/bubbles%202/pictures/index/ludo.jpg', 
                'https://jwk.no/bubbles%202/pictures/index/stolen.jpg',
                'https://jwk.no/bubbles%202/pictures/index/oval.jpg',
                'https://jwk.no/bubbles%202/pictures/index/front_without.jpg',
                'https://jwk.no/bubbles%202/pictures/index/dorhondtak.jpg',
                'https://jwk.no/bubbles%202/pictures/index/benk.jpg'
            ],
            TEXTS: [
                { text: "Velkommen til en reise\ngjennom farger og former", fontSize: 32, color: '#ffffff' },
                { text: "Hvert design er bygget opp\nav tusenvis av lyspunkt", fontSize: 32, color: '#ffffff' },
                { text: "Form og farge flyter over\ni en sømløs overgang", fontSize: 32, color: '#ffffff' },
                { text: "Teksten følger den samme\nreisen som bildene", fontSize: 32, color: '#ffffff' },
                { text: "Drevet av Three.js\nog en custom partikkelmotor", fontSize: 32, color: '#ffffff' },
                { text: "Takk for at du tok deg tid\ntil å se på prosjektet", fontSize: 32, color: '#ffffff' },
                { text: "Slutt på presentasjonen", fontSize: 32, color: '#ffffff' }
            ],
            MAX_DIMENSION: 400, PARTICLE_SIZE: 0.8, TEXT_PARTICLE_SIZE: 1.5,
            SCROLL_DAMPENING: 0.05,
            CAMERA_SMOOTHING: 0.08,
            BUILD_WAVE_DELAY: 0.4, BUILD_START_DISTANCE: 200, TRANSITION_WAVE_DELAY: 0.2,
            BUILD_CHAOS_STRENGTH: 5000, TRANSITION_CHAOS_STRENGTH: 800,
            AMBIENT_STRENGTH: 10, AMBIENT_SPEED: 0.0015,
        };

        gsap.registerPlugin(ScrollToPlugin);
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(window.innerWidth/-2, window.innerWidth/2, window.innerHeight/2, window.innerHeight/-2, 1, 10000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('particle-canvas'), alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        let imageParticlesData = [], textParticlesData = [];
        let imageGeometry, textGeometry, imagePoints, textPoints;
        let imageRefs = [], textRefs = [];
        let smoothScrollProgress = 0, smoothCameraY = 0;
        let clock = new THREE.Clock();

        let currentSectionIndex = 0;
        let isAnimatingScroll = false;
        const totalSections = settings.IMAGE_URLS.length;

        // Touch handling variables
        let touchStartY = 0;
        let touchStartTime = 0;
        let lastTouchMove = 0;
        const minSwipeDistance = 50;
        const maxSwipeTime = 300;

        const lerp = (a, b, t) => a + (b - a) * t;
        const easeOutQuart = t => 1 - Math.pow(1 - t, 4);
        const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

        function getTextPixelData(text, fontSize, color) {
            const dpr = window.devicePixelRatio || 3;
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            ctx.font = `bold ${fontSize * dpr}px 'Helvetica Neue', sans-serif`;
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2 * dpr;
            const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
            canvas.width = maxWidth + 20 * dpr; canvas.height = lines.length * lineHeight + 20 * dpr;
            ctx.fillStyle = color; ctx.font = `bold ${fontSize * dpr}px 'Helvetica Neue', sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            lines.forEach((line, i) => ctx.fillText(line, canvas.width/2, (canvas.height/2) + (i - (lines.length-1)/2)*lineHeight));
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data;
            const pixels = [];
            let minY = Infinity, maxY = -Infinity;
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 200) {
                        const rY = -y/dpr + (canvas.height/2/dpr);
                        if (rY < minY) minY = rY; if (rY > maxY) maxY = rY;
                        pixels.push({ x: x/dpr - canvas.width/2/dpr, y: rY, normalizedY: 0 });
                    }
                }
            }
            pixels.forEach(p => { p.normalizedY = (p.y - minY) / (maxY - minY || 1); });
            return pixels;
        }
        
        const createRandomOffsets = () => ({
            randomOffset: Math.random(), chaosOffsetX: (Math.random()-0.5), chaosOffsetY: (Math.random()-0.5), chaosOffsetZ: (Math.random()-0.5),
            ambientAngle: Math.random()*Math.PI*2, ambientSpeed: settings.AMBIENT_SPEED*(0.5+Math.random()*0.5)
        });

        async function setup() {
            document.querySelectorAll('.image-reference').forEach(el => imageRefs.push(el));
            document.querySelectorAll('.text-reference').forEach(el => textRefs.push(el));
            
            const textures = await Promise.all(settings.IMAGE_URLS.map(url => new THREE.TextureLoader().loadAsync(url)));
            textures.forEach(t => t.colorSpace = THREE.SRGBColorSpace);
            const ratio = textures[0].image.naturalWidth / textures[0].image.naturalHeight;
            const displayW = settings.MAX_DIMENSION; const displayH = settings.MAX_DIMENSION / ratio;
            imageRefs.forEach(ref => { ref.style.width = `${displayW}px`; ref.style.height = `${displayH}px`; });
            textRefs.forEach(ref => { ref.style.height = `${displayH}px`; });
            
            const allImageData = textures.map(tex => {
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                canvas.width = displayW; canvas.height = displayH;
                ctx.drawImage(tex.image, 0, 0, displayW, displayH);
                return ctx.getImageData(0, 0, displayW, displayH).data;
            });
            let particlePresence = new Uint8Array(displayW * displayH).fill(0);
            allImageData.forEach(data => { for (let i = 0; i < data.length; i += 4) if (data[i + 3] > 128) particlePresence[i / 4] = 1; });
            let imgMinY = Infinity, imgMaxY = -Infinity;
            for (let y = 0; y < displayH; y++) {
                for (let x = 0; x < displayW; x++) {
                    if (particlePresence[y * displayW + x]) {
                        const rY = -y + displayH / 2;
                        if (rY < imgMinY) imgMinY = rY; if (rY > imgMaxY) imgMaxY = rY;
                        imageParticlesData.push({
                            relativeX: x - displayW / 2, relativeY: rY,
                            colors: allImageData.map(data => new THREE.Color(data[(y*displayW+x)*4]/255, data[(y*displayW+x)*4+1]/255, data[(y*displayW+x)*4+2]/255).convertSRGBToLinear()),
                            normalizedY: 0, ...createRandomOffsets()
                        });
                    }
                }
            }
            imageParticlesData.forEach(p => { p.normalizedY = (p.relativeY - imgMinY) / (imgMaxY - imgMinY || 1); });
            const allTextPixels = settings.TEXTS.map(t => getTextPixelData(t.text, t.fontSize, t.color));
            const maxTextParticles = Math.max(...allTextPixels.map(p => p.length));
            for (let i = 0; i < maxTextParticles; i++) {
                textParticlesData.push({
                    relativePositions: allTextPixels.map(pixels => pixels[i % pixels.length]),
                    colors: allTextPixels.map(pixels => new THREE.Color(pixels.color).convertSRGBToLinear()),
                    normalizedY: allTextPixels[0][i % allTextPixels[0].length].normalizedY,
                    ...createRandomOffsets()
                });
            }

            createGeometry();
            setupNavigation();
            animate();
        }
        
        function setupNavigation() {
            let welcomeHidden = false;
            
            // Helper function to navigate sections
            function navigateToSection(direction) {
                if (isAnimatingScroll) return false;
                
                if (direction === 'next' && currentSectionIndex < totalSections - 1) {
                    currentSectionIndex++;
                    scrollToSection(currentSectionIndex);
                    return true;
                } else if (direction === 'prev' && currentSectionIndex > 0) {
                    currentSectionIndex--;
                    scrollToSection(currentSectionIndex);
                    return true;
                }
                return false;
            }

            // Helper function to hide welcome overlay
            function hideWelcomeOverlay() {
                if (!welcomeHidden) {
                    document.getElementById('welcome-overlay').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('welcome-overlay').style.display = 'none';
                        // Show touch indicator briefly after welcome is hidden
                        const indicator = document.getElementById('touch-indicator');
                        indicator.style.opacity = '1';
                        setTimeout(() => {
                            indicator.style.opacity = '0';
                        }, 3000);
                    }, 500);
                    welcomeHidden = true;
                    return true;
                }
                return false;
            }
            
            // Keyboard navigation
            window.addEventListener('keydown', (e) => {
                // Hide welcome on first key press
                if (hideWelcomeOverlay()) return;
                
                if (e.key === 'ArrowDown') {
                    navigateToSection('next');
                } else if (e.key === 'ArrowUp') {
                    navigateToSection('prev');
                }
            });

            // Touch navigation
            window.addEventListener('touchstart', (e) => {
                // Hide welcome on first touch
                if (hideWelcomeOverlay()) {
                    e.preventDefault();
                    return;
                }

                touchStartY = e.touches[0].clientY;
                touchStartTime = Date.now();
                lastTouchMove = touchStartY;
            }, { passive: false });

            window.addEventListener('touchmove', (e) => {
                if (!welcomeHidden) {
                    e.preventDefault();
                    return;
                }
                
                lastTouchMove = e.touches[0].clientY;
                // Prevent default scrolling behavior
                e.preventDefault();
            }, { passive: false });

            window.addEventListener('touchend', (e) => {
                if (!welcomeHidden) return;
                
                const touchEndY = lastTouchMove;
                const touchDuration = Date.now() - touchStartTime;
                const swipeDistance = touchStartY - touchEndY;
                const swipeSpeed = Math.abs(swipeDistance) / touchDuration;

                // Check if it's a valid swipe
                if (touchDuration <= maxSwipeTime && Math.abs(swipeDistance) >= minSwipeDistance) {
                    if (swipeDistance > 0) {
                        // Swipe up = next section
                        navigateToSection('next');
                    } else {
                        // Swipe down = previous section  
                        navigateToSection('prev');
                    }
                }
                
                e.preventDefault();
            }, { passive: false });

            // Prevent default touch behaviors that might interfere
            window.addEventListener('touchcancel', (e) => {
                e.preventDefault();
            }, { passive: false });
        }

        function scrollToSection(index) {
            isAnimatingScroll = true;
            const totalScrollHeight = document.body.scrollHeight - window.innerHeight;
            const targetScrollY = (index / (totalSections - 1)) * totalScrollHeight;

            gsap.to(window, {
                scrollTo: { y: targetScrollY, autoKill: true },
                duration: 5.5,
                ease: "power2.inOut",
                onComplete: () => { isAnimatingScroll = false; }
            });
        }
        
        function createGeometry() {
            imageGeometry = new THREE.BufferGeometry();
            imageGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(imageParticlesData.length * 3), 3));
            imageGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(imageParticlesData.length * 3), 3));
            imagePoints = new THREE.Points(imageGeometry, new THREE.PointsMaterial({ size: settings.PARTICLE_SIZE, vertexColors: true, sizeAttenuation: false }));
            scene.add(imagePoints);
            textGeometry = new THREE.BufferGeometry();
            textGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(textParticlesData.length * 3), 3));
            textGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(textParticlesData.length * 3), 3));
            textPoints = new THREE.Points(textGeometry, new THREE.PointsMaterial({ size: settings.TEXT_PARTICLE_SIZE, vertexColors: true, sizeAttenuation: false }));
            scene.add(textPoints);
        }

        const getRefPos = (ref) => {
            const rect = ref.getBoundingClientRect();
            return { x: rect.left + rect.width / 2 - window.innerWidth / 2, y: -(rect.top + rect.height / 2) + window.innerHeight / 2 };
        };

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const totalScrollHeight = document.body.scrollHeight - window.innerHeight;
            const rawScrollProgress = totalScrollHeight > 0 ? window.scrollY / totalScrollHeight : 0;
            smoothScrollProgress = lerp(smoothScrollProgress, rawScrollProgress, settings.SCROLL_DAMPENING);

            let avgY = 0;

            const globalProgress = smoothScrollProgress * (totalSections - 1);
            const fromIndex = Math.floor(globalProgress);
            const toIndex = Math.min(fromIndex + 1, totalSections - 1);
            const localProgress = globalProgress - fromIndex;
            
            const buildProgress = smoothScrollProgress * (totalSections - 1);
            let currentChaosStrength = lerp(settings.BUILD_CHAOS_STRENGTH, settings.TRANSITION_CHAOS_STRENGTH, easeOutQuart(buildProgress < 1 ? buildProgress : 1));

            const imageStartRef = getRefPos(imageRefs[fromIndex]);
            const imageEndRef = getRefPos(imageRefs[toIndex]);
            const textStartRef = getRefPos(textRefs[fromIndex]);
            const textEndRef = getRefPos(textRefs[toIndex]);
            
            const imagePositions = imageGeometry.attributes.position.array;
            const imageColors = imageGeometry.attributes.color.array;
            for (let i = 0; i < imageParticlesData.length; i++) {
                const p = imageParticlesData[i];
                const finalState = updateParticle(p, localProgress, buildProgress, currentChaosStrength, time, imageStartRef, imageEndRef, p.relativeX, p.relativeY, fromIndex, toIndex);
                finalState.pos.toArray(imagePositions, i * 3);
                finalState.color.toArray(imageColors, i * 3);
                avgY += finalState.pos.y;
            }
            const textPositions = textGeometry.attributes.position.array;
            const textColors = textGeometry.attributes.color.array;
            for (let i = 0; i < textParticlesData.length; i++) {
                const p = textParticlesData[i];
                const rStartX = p.relativePositions[fromIndex].x;
                const rStartY = p.relativePositions[fromIndex].y;
                const rEndX = p.relativePositions[toIndex].x;
                const rEndY = p.relativePositions[toIndex].y;
                const rX = lerp(rStartX, rEndX, easeInOutCubic(localProgress));
                const rY = lerp(rStartY, rEndY, easeInOutCubic(localProgress));
                const finalState = updateParticle(p, localProgress, buildProgress, currentChaosStrength/2, time, textStartRef, textEndRef, rX, rY, fromIndex, toIndex);
                finalState.pos.toArray(textPositions, i * 3);
                finalState.color.set(settings.TEXTS[fromIndex].color).convertSRGBToLinear().toArray(textColors, i*3);
                avgY += finalState.pos.y;
            }

            const totalParticles = imageParticlesData.length + textParticlesData.length;
            if (totalParticles > 0) avgY /= totalParticles;

            if (!isNaN(avgY)) {
                smoothCameraY = lerp(smoothCameraY, avgY, settings.CAMERA_SMOOTHING);
                camera.position.y = smoothCameraY;
            }
            
            imageGeometry.attributes.position.needsUpdate = true;
            imageGeometry.attributes.color.needsUpdate = true;
            textGeometry.attributes.position.needsUpdate = true;
            textGeometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function updateParticle(p, localProgress, buildProgress, chaosStrength, time, startRef, endRef, relativeX, relativeY, fromIndex, toIndex) {
            const personalBuildProgress = easeOutQuart(Math.max(0, Math.min(1, (buildProgress - p.normalizedY * settings.BUILD_WAVE_DELAY) / (1 - settings.BUILD_WAVE_DELAY || 1))));
            const transitionDelay = p.normalizedY * settings.TRANSITION_WAVE_DELAY + p.randomOffset * 0.15;
            const personalTransitionProgress = easeInOutCubic(Math.max(0, Math.min(1, (localProgress - transitionDelay) / (1 - transitionDelay || 1))));
            
            const anchorX = lerp(startRef.x, endRef.x, personalTransitionProgress) + relativeX;
            const anchorY = lerp(startRef.y, endRef.y, personalTransitionProgress) + relativeY;

            const fromColor = p.colors ? p.colors[fromIndex] : null;
            const toColor = p.colors ? p.colors[toIndex] : null;
            const finalColor = fromColor && toColor ? fromColor.clone().lerp(toColor, personalTransitionProgress) : new THREE.Color(settings.TEXTS[0].color);

            const chaosFactor = (1 - personalBuildProgress) + Math.sin(personalTransitionProgress * Math.PI) * 0.8;
            const buildOffsetY = settings.BUILD_START_DISTANCE * (1 - personalBuildProgress);
            const ambientX = Math.cos(p.ambientAngle + time * p.ambientSpeed) * settings.AMBIENT_STRENGTH;
            const ambientY = Math.sin(p.ambientAngle + time * p.ambientSpeed) * settings.AMBIENT_STRENGTH;
            
            const finalPos = new THREE.Vector3(
                anchorX + (p.chaosOffsetX * chaosStrength + ambientX) * chaosFactor,
                anchorY + buildOffsetY + (p.chaosOffsetY * chaosStrength + ambientY) * chaosFactor,
                (p.chaosOffsetZ * chaosStrength) * chaosFactor
            );
            
            return { pos: finalPos, color: finalColor };
        }
        
        setup().catch(err => console.error("Feil ved oppsett:", err));
        window.addEventListener('resize', () => { window.location.reload(); });
    </script>
</body>
</html>
