<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    
    <title>Partikkel-Portfolio med Dynamisk Layout</title>
    <style>


body { 
    margin: 0; 
    background: linear-gradient(135deg, rgb(0, 4, 19) 0%, rgb(41, 55, 82) 50%, rgb(0, 4, 19) 100%);
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-size: cover;
    color: #fff; 
    font-family: 'Helvetica Neue', sans-serif; 
    overflow: hidden; 
    visibility: hidden;
    touch-action: none;
}

canvas { 
    position: fixed; 
    top: 0; 
    left: 0; 
    z-index: 1; 
    pointer-events: none; 
}

#content-container {
    position: relative;
    z-index: 2;
    width: 500vw;
    height: 500vh;
}

.scroll-section {
    position: absolute;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.text-reference, .image-reference {
    position: absolute;
    opacity: 0; 
    pointer-events: none;
}

.image-clickable {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5;
    cursor: pointer;
    background: transparent;
    pointer-events: auto;
}

.image-clickable:hover {
    background: rgba(255, 255, 255, 0.1);
    transition: background 0.3s ease;
}

#image-ref-1 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
#text-ref-1  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }

#image-ref-2 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
#text-ref-2  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }

#image-ref-3 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
#text-ref-3  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }

#image-ref-4 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
#text-ref-4  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }

#image-ref-5 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
#text-ref-5  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }

#image-ref-6 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
#text-ref-6  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }

#welcome-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.8);
    z-index: 20;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 1;
    transition: opacity 0.8s ease-out;
    pointer-events: none;
}

#welcome-overlay.fade-out {
    opacity: 0;
}

#welcome-text {
    text-align: center;
    font-size: 24px;
    line-height: 1.6;
    max-width: 600px;
    padding: 40px;
    color: #ffffff;
    font-weight: 300;
}

#welcome-text h1 {
    font-size: 32px;
    margin-bottom: 20px;
    font-weight: 400;
}

#progress-indicator {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 10;
    color: #fff;
    font-size: 14px;
    opacity: 0.8;
    background-color: rgba(0,0,0,0.6);
    padding: 5px 10px;
    border-radius: 5px;
}

#controls {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 10;
    display: flex;
    gap: 10px;
}

.control-btn {
    background-color: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 12px;
    transition: background-color 0.3s;
}

.control-btn:hover {
    background-color: rgba(255,255,255,0.3);
}

.control-btn.active {
    background-color: rgba(255,255,255,0.4);
}

#navigation-hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    color: #fff;
    font-size: 16px;
    opacity: 0.8;
    background-color: rgba(0,0,0,0.6);
    padding: 10px 20px;
    border-radius: 20px;
    text-align: center;
}

body.scroll-mode {
    overflow: auto;
}

body.scroll-mode #content-container {
    width: 100vw;
    height: 700vh; /* 7 seksjoner x 100vh */
}

body.scroll-mode .scroll-section {
    position: relative;
    left: 0 !important;
    top: 0 !important;
    width: 100vw;
    height: 100vh;
}



/* Progress Bar Styles */
#progress-bar-container {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 15;
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 115px;
   
    padding: 15px 25px;
    border-radius: 30px;
   
    
   
}

/* Horisontal linje i midten */
#progress-bar-container::before {
    content: '';
    position: absolute;
    top: 50%;
    
    height: 10px;
    width: 90%;
    background: linear-gradient(to right, 
        rgba(255, 255, 255, 0.1), 
        rgba(255, 255, 255, 0.3), 
        rgba(255, 255, 255, 0.1));
    transform: translateY(-50%);
    z-index: 0;
}

.progress-dot {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 1.0s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    
   
    background-size: cover;
    background-position: center;
    
}

.progress-dot:hover {
    
    transform: scale(1.4);
}

.progress-dot.active {
    border: 1px solid rgb(255, 255, 255);
    transform: scale(1.4);
    box-shadow: 0 0 2px rgba(255, 255, 255, 0.6);


}

.progress-dot.dissolved {
    background: rgba(100, 150, 255, 0.7);
    box-shadow: 0 0 8px rgba(100, 150, 255, 0.5);
}

.progress-dot::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: -35px;
    left: 50%;
    transform: translateX(-50%);
    
    color: rgb(255, 255, 255);
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 15px;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    font-weight: 400;
    z-index: 10;
}

.progress-dot:hover::after {
    opacity: 1;
}

.progress-dot.active::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: -35px;
    left: 50%;
    transform: translateX(-50%);
    
    color: #e8e8e8;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 15px;
    white-space: nowrap;
    font-weight: 400;
    z-index: 10;
}


@media (max-width: 999px) {
    .scroll-section {
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
    }

    /* Reset alle posisjonering for responsive layout */
    #image-ref-1, #image-ref-2, #image-ref-3, 
    #image-ref-4, #image-ref-5, #image-ref-6 {
        position: relative !important;
        top: auto !important;
        left: auto !important;
        transform: none !important;
        margin-bottom: 60px;
        width: 90vw !important;
        max-width: 400px !important;
        height: auto !important;
    }

    #text-ref-1, #text-ref-2, #text-ref-3,
    #text-ref-4, #text-ref-5, #text-ref-6 {
        position: relative !important;
        top: auto !important;
        left: auto !important;
        transform: none !important;
        width: 90vw !important;
        max-width: 400px !important;
        height: auto !important;
        text-align: center;
    }

    /* Juster bildestørrelser for mindre skjermer */
    .image-reference {
        width: 90vw !important;
        max-width: 400px !important;
        height: auto !important;
        aspect-ratio: 1; /* Behold kvadratisk form hvis ønskelig */
    }

    /* Juster tekststørrelser for mindre skjermer */
    .text-reference {
        width: 90vw !important;
        max-width: 400px !important;
        padding: 10px;
        font-size: 14px;
        line-height: 1.4;
    }
}

/* For enda mindre skjermer (telefoner) */
@media (max-width: 600px) {
    .scroll-section {
        padding: 15px;
    }

    #image-ref-1, #image-ref-2, #image-ref-3, 
    #image-ref-4, #image-ref-5, #image-ref-6 {
        width: 95vw !important;
        max-width: 350px !important;
        margin-bottom: 15px;
    }

    #text-ref-1, #text-ref-2, #text-ref-3,
    #text-ref-4, #text-ref-5, #text-ref-6 {
        width: 95vw !important;
        max-width: 350px !important;
        font-size: 12px;
    }

    /* Juster kontroller for mindre skjermer */
    #controls {
        top: 10px;
        right: 10px;
        gap: 5px;
    }

    .control-btn {
        padding: 6px 8px;
        font-size: 10px;
    }

    #progress-indicator {
        top: 10px;
        left: 10px;
        font-size: 12px;
        padding: 3px 6px;
    }

    #navigation-hint {
        bottom: 10px;
        font-size: 14px;
        padding: 8px 15px;
    }
}

/* Spesifikk justering for scroll modus på mindre skjermer */
@media (max-width: 999px) {
    body.scroll-mode #content-container {
        width: 100vw !important;
    }

    body.scroll-mode .scroll-section {
        position: relative !important;
        left: 0 !important;
        top: 0 !important;
        width: 100vw !important;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 40px 20px;
        box-sizing: border-box;
    }
}

    </style>
</head>
<body>

    <div id="welcome-overlay">
        <div id="welcome-text">
            <h1>Hi, I'm Johannes Worren Kløcker</h1>
            <p>I believe all design should be interesting and create curiosity.<br>
            Here's my portfolio.<br><br>
            Use your arrow keys to explore.<br>
            Happy exploring!</p>
        </div>
    </div>

    <!-- Progress Bar -->
    <div id="progress-bar-container">
    
        <div class="progress-dot" data-tooltip="Ludo" data-section="0"></div>
        <div class="progress-dot" data-tooltip="Stolen" data-section="1"></div>
        <div class="progress-dot" data-tooltip="Oval" data-section="2"></div>
        <div class="progress-dot" data-tooltip="Front" data-section="3"></div>
        <div class="progress-dot" data-tooltip="Dørhåndtak" data-section="4"></div>
        <div class="progress-dot" data-tooltip="Benk" data-section="5"></div>
    </div>

    



    <canvas id="particle-canvas"></canvas>
    <div id="progress-indicator"></div>
    <div id="controls">
        <button class="control-btn" id="scroll-mode-btn">Scroll Modus</button>
        <button class="control-btn" id="reset-btn">Reset</button>
    </div>

    <div id="navigation-hint">Bruk piltastene for å navigere</div>
    
    <div id="content-container">
        <div class="scroll-section">
            <div id="image-ref-1" class="image-reference">
                <a href="https://jwk.no/ludo" class="image-clickable" target="_blank"></a>
            </div>
            <div id="text-ref-1" class="text-reference"></div>
        </div>
        <div class="scroll-section">
            <div id="image-ref-2" class="image-reference">
                <a href="https://jwk.no/stolen" class="image-clickable" target="_blank"></a>
            </div>
            <div id="text-ref-2" class="text-reference"></div>
        </div>
        <div class="scroll-section">
            <div id="image-ref-3" class="image-reference">
                <a href="https://jwk.no/oval" class="image-clickable" target="_blank"></a>
            </div>
            <div id="text-ref-3" class="text-reference"></div>
        </div>
        <div class="scroll-section">
            <div id="image-ref-4" class="image-reference">
                <a href="https://jwk.no/front" class="image-clickable" target="_blank"></a>
            </div>
            <div id="text-ref-4" class="text-reference"></div>
        </div>
        <div class="scroll-section">
            <div id="image-ref-5" class="image-reference">
                <a href="https://jwk.no/dorhondtak" class="image-clickable" target="_blank"></a>
            </div>
            <div id="text-ref-5" class="text-reference"></div>
        </div>
        <div class="scroll-section">
            <div id="image-ref-6" class="image-reference">
                <a href="https://jwk.no/benk" class="image-clickable" target="_blank"></a>
            </div>
            <div id="text-ref-6" class="text-reference"></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollToPlugin.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.156.1/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- INNSTILLINGER ---
        const settings = {
            IMAGE_URLS: [ 
                'https://jwk.no/bubbles%202/pictures/index/ludo.jpg', 
                'https://jwk.no/bubbles%202/pictures/index/stolen.jpg',
                'https://jwk.no/bubbles%202/pictures/index/oval.jpg',
                'https://jwk.no/bubbles%202/pictures/index/front_without.jpg',
                'https://jwk.no/bubbles%202/pictures/index/dorhondtak.jpg',
                'https://jwk.no/bubbles%202/pictures/index/benk.jpg'
            ],
            TEXTS: [
                { text: "Velkommen til min portefølje\nTrykk Scroll Modus eller bruk piltastene", fontSize: 40, color: '#ffffff' },
                { text: "Hvert design er bygget opp\nav tusenvis av lyspunkt", fontSize: 32, color: '#ffffff' },
                { text: "Form og farge flyter over\ni en sømløs overgang", fontSize: 32, color: '#ffffff' },
                { text: "Teksten følger den samme\nreisen som bildene", fontSize: 32, color: '#ffffff' },
                { text: "Drevet av Three.js\nog en custom partikkelmotor", fontSize: 32, color: '#ffffff' },
                { text: "Takk for at du tok deg tid\ntil å se på prosjektet", fontSize: 32, color: '#ffffff' }
            ],
            MAX_DIMENSION: 600, PARTICLE_SIZE: 0.5, TEXT_PARTICLE_SIZE: 0.15, // Justert tilbake til rimelig størrelse
            CAMERA_SMOOTHING: 0.4,
            BUILD_WAVE_DELAY: 0.1, BUILD_START_DISTANCE: 100, TRANSITION_WAVE_DELAY: 0.7,
            BUILD_CHAOS_STRENGTH: 5000, TRANSITION_CHAOS_STRENGTH: 1000,
            AMBIENT_STRENGTH: 100, AMBIENT_SPEED: 0.15,
        };

        gsap.registerPlugin(ScrollToPlugin);
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(window.innerWidth/-2, window.innerWidth/2, window.innerHeight/2, window.innerHeight/-2, 1, 10000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('particle-canvas'), alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        let imageParticlesData = [], textParticlesData = [];
        let imageGeometry, textGeometry, imagePoints, textPoints;
        let imageRefs = [], textRefs = [], scrollSections = [];
        let clock = new THREE.Clock();

        let currentStopIndex = 0;
        let isAnimatingScroll = false;
        let isScrollMode = false;
        
        // NYTT: Bruker -1 for å indikere oppløst tilstand (seksjon 1)
        let currentSection = -1; // -1 = oppløst, 0 = første bilde/tekst, 1 = andre bilde/tekst, osv.
        
        let transitionState = { progress: 0.0, buildProgress: 0.0 }; 
        let fromIndex = 0;
        let toIndex = 0;
        
        const TRANSITION_DURATION = 5.0;
        
        // Scroll dampening variabler
        let targetScrollProgress = 0;
        let currentScrollProgress = 0;
        const SCROLL_DAMPENING = 0.08; // Juster denne verdien for mer/mindre dampening (lavere = mer dampening)

        const lerp = (a, b, t) => a + (b - a) * t;
        const easeOutQuart = t => 1 - Math.pow(1 - t, 4);
        const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

        // Progress Bar Functions
        function updateProgressBar() {
    const dots = document.querySelectorAll('.progress-dot');
    
    dots.forEach((dot, index) => {
        const sectionIndex = parseInt(dot.dataset.section);
        dot.classList.remove('active');
        
        if (currentSection === sectionIndex) {
            dot.classList.add('active');
        }
    });
}

function setupProgressBar() {
    const dots = document.querySelectorAll('.progress-dot');
    
    // Set background images for product dots
    const imageUrls = settings.IMAGE_URLS;
    dots.forEach((dot, index) => {
        const sectionIndex = parseInt(dot.dataset.section);
        if (sectionIndex >= 0 && sectionIndex < imageUrls.length) {
            dot.style.backgroundImage = `url('${imageUrls[sectionIndex]}')`;
        }
        
        dot.addEventListener('click', () => {
            const targetSection = parseInt(dot.dataset.section);
            if (targetSection !== currentSection && !isAnimatingScroll) {
                navigateToSection(targetSection);
            }
        });
    });
}

        function getTextPixelData(text, fontSize, color) {
            const dpr = window.devicePixelRatio || 3;
            const SAMPLING_DENSITY = 2; // Øk denne verdien for mindre density (mer spacing mellom partikler)
            
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            ctx.font = `bold ${fontSize * dpr}px 'Helvetica Neue', sans-serif`;
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2 * dpr;
            const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
            canvas.width = maxWidth + 20 * dpr; canvas.height = lines.length * lineHeight + 20 * dpr;
            ctx.fillStyle = color; ctx.font = `bold ${fontSize * dpr}px 'Helvetica Neue', sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            lines.forEach((line, i) => ctx.fillText(line, canvas.width/2, (canvas.height/2) + (i - (lines.length-1)/2)*lineHeight));
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data;
            const pixels = [];
            let minY = Infinity, maxY = -Infinity;
            
            // Sample hver SAMPLING_DENSITY piksel i stedet for hver piksel
            for (let y = 0; y < canvas.height; y += SAMPLING_DENSITY) {
                for (let x = 0; x < canvas.width; x += SAMPLING_DENSITY) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 200) {
                        const rY = -y/dpr + (canvas.height/2/dpr);
                        if (rY < minY) minY = rY; if (rY > maxY) maxY = rY;
                        pixels.push({ x: x/dpr - canvas.width/2/dpr, y: rY, normalizedY: 0 });
                    }
                }
            }
            pixels.forEach(p => { p.normalizedY = (p.y - minY) / (maxY - minY || 1); });
            return pixels;
        }
        
        const createRandomOffsets = () => ({
             randomOffset: Math.random(), chaosOffsetX: (Math.random()-0.5), chaosOffsetY: (Math.random()-0.5), chaosOffsetZ: (Math.random()-0.5),
            ambientAngle: Math.random()*Math.PI*2, ambientSpeed: settings.AMBIENT_SPEED*(0.5+Math.random()*0.5)
        });

        async function setup() {
            document.querySelectorAll('.image-reference').forEach(el => imageRefs.push(el));
            document.querySelectorAll('.text-reference').forEach(el => textRefs.push(el));
            scrollSections = Array.from(document.querySelectorAll('.scroll-section'));

            const contentContainer = document.getElementById('content-container');
            const containerW = contentContainer.offsetWidth - window.innerWidth;
            const containerH = contentContainer.offsetHeight - window.innerHeight;
            let positions = [];
            const startX = containerW / 2;
            const startY = 0;
            positions.push({ x: startX, y: startY });
            const minDistance = window.innerWidth * 0.1
            ; 
            for (let i = 1; i < scrollSections.length; i++) {
                let newPos;
                let attempts = 0;
                do {
                    newPos = { x: Math.random() * containerW, y: Math.random() * containerH };
                    attempts++;
                } while (positions.some(p => Math.hypot(p.x - newPos.x, p.y - newPos.y) < minDistance) && attempts < 50);
                positions.push(newPos);
            }
            scrollSections.forEach((section, index) => {
                section.style.left = `${positions[index].x}px`;
                section.style.top = `${positions[index].y}px`;
            });
            
            const textures = await Promise.all(settings.IMAGE_URLS.map(url => new THREE.TextureLoader().loadAsync(url)));
            textures.forEach(t => t.colorSpace = THREE.SRGBColorSpace);
            const ratio = textures[0].image.naturalWidth / textures[0].image.naturalHeight;
            const displayW = settings.MAX_DIMENSION; const displayH = settings.MAX_DIMENSION / ratio;
            imageRefs.forEach(ref => { ref.style.width = `${displayW}px`; ref.style.height = `${displayH}px`; });
            textRefs.forEach(ref => { ref.style.width = '450px'; ref.style.height = `${displayH}px`; }); 
            
            const allImageData = textures.map(tex => {
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                canvas.width = displayW; canvas.height = displayH;
                ctx.drawImage(tex.image, 0, 0, displayW, displayH);
                return ctx.getImageData(0, 0, displayW, displayH).data;
            });
            
            const IMAGE_SAMPLING_DENSITY = 1; // Øk denne verdien for mindre density
            
            let particlePresence = new Uint8Array(displayW * displayH).fill(0);
            allImageData.forEach(data => { 
                // Sample med density intervaller
                for (let y = 0; y < displayH; y += IMAGE_SAMPLING_DENSITY) {
                    for (let x = 0; x < displayW; x += IMAGE_SAMPLING_DENSITY) {
                        const i = (y * displayW + x) * 4;
                        if (data[i + 3] > 128) particlePresence[y * displayW + x] = 1;
                    }
                }
            });
            
            let imgMinY = Infinity, imgMaxY = -Infinity;
            for (let y = 0; y < displayH; y += IMAGE_SAMPLING_DENSITY) {
                for (let x = 0; x < displayW; x += IMAGE_SAMPLING_DENSITY) {
                    if (particlePresence[y * displayW + x]) {
                        const rY = -y + displayH / 2;
                        if (rY < imgMinY) imgMinY = rY; if (rY > imgMaxY) imgMaxY = rY;
                        imageParticlesData.push({
                            relativeX: x - displayW / 2, relativeY: rY,
                            colors: allImageData.map(data => new THREE.Color(data[(y*displayW+x)*4]/255, data[(y*displayW+x)*4+1]/255, data[(y*displayW+x)*4+2]/255).convertSRGBToLinear()),
                            normalizedY: 0, ...createRandomOffsets()
                        });
                    }
                }
            }
            imageParticlesData.forEach(p => { p.normalizedY = (p.relativeY - imgMinY) / (imgMaxY - imgMinY || 1); });
            
            const allTextPixels = settings.TEXTS.map(t => getTextPixelData(t.text, t.fontSize, t.color));
            const maxTextParticles = Math.max(0, ...allTextPixels.map(p => p.length));
            
            if (maxTextParticles > 0) {
                for (let i = 0; i < maxTextParticles; i++) {
                    textParticlesData.push({
                        relativePositions: allTextPixels.map(pixels => {
                            if (pixels.length === 0) return { x: 0, y: 0, normalizedY: 0.5 };
                            return pixels[i % pixels.length];
                        }),
                        colors: settings.TEXTS.map(text => new THREE.Color(text.color).convertSRGBToLinear()),
                        normalizedY: allTextPixels[0].length > 0 ? (allTextPixels[0][i % allTextPixels[0].length]?.normalizedY || 0.5) : 0.5,
                        ...createRandomOffsets()
                    });
                }
            }

            createGeometry();
            setupNavigation();
            setupControls();
            setupProgressBar();
            
         // Start med oppløste partikler (seksjon -1)
currentSection = -1;
fromIndex = 0;
toIndex = 0;
transitionState.progress = 1.0;
transitionState.buildProgress = 0.0;
targetScrollProgress = 0;
currentScrollProgress = 0;

const startSection = scrollSections[0];
const initialX = startSection.offsetLeft + startSection.offsetWidth / 2 - window.innerWidth / 2;
const initialY = startSection.offsetTop + startSection.offsetHeight / 2 - window.innerHeight / 2;
window.scrollTo(initialX, initialY);

// Touch swipe detection og prevent native scrolling
let touchStartY = 0;
let touchStartTime = 0;

document.addEventListener('touchstart', (e) => {
    if (e.target.tagName !== 'BUTTON' && !e.target.classList.contains('progress-dot') && !isScrollMode) {
        e.preventDefault();
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
    }
}, { passive: false });

document.addEventListener('touchmove', (e) => {
    if (!isScrollMode) {
        e.preventDefault();
    }
}, { passive: false });

document.addEventListener('touchend', (e) => {
    if (e.target.tagName !== 'BUTTON' && !e.target.classList.contains('progress-dot') && !isScrollMode) {
        e.preventDefault();
        
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        const deltaY = touchStartY - touchEndY;
        const deltaTime = touchEndTime - touchStartTime;
        
        // Sjekk for gyldig swipe (minimum 50px, maksimum 500ms)
        if (Math.abs(deltaY) > 50 && deltaTime < 500) {
            if (isAnimatingScroll) return;
            
            if (deltaY > 0) {
                // Swipe opp = neste seksjon
                if (currentSection < scrollSections.length - 1) {
                    navigateToSection(currentSection + 1);
                    
                }
            } else {
                // Swipe ned = forrige seksjon
                if (currentSection > -1) {
                    navigateToSection(currentSection - 1);
                    
                }
            }
        }
    }
}, { passive: false });

requestAnimationFrame(() => {
    animate(); 
    document.body.style.visibility = 'visible';
    
    
});
}
function setupNavigation() {
    // Welcome overlay håndtering
    let welcomeShown = true;
    const welcomeOverlay = document.getElementById('welcome-overlay');

    function hideWelcome() {
        if (welcomeShown) {
            welcomeOverlay.classList.add('fade-out');
            setTimeout(() => {
                welcomeOverlay.style.display = 'none';
            }, 800);
            welcomeShown = false;
        }
    }

    // Touch for welcome
    document.addEventListener('touchstart', hideWelcome, { passive: true });

    // Kombinert keyboard listener
    window.addEventListener('keydown', (e) => {
        // Sjekk welcome først
        if (welcomeShown && (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
            hideWelcome();
            return; // Stop her så navigasjon ikke skjer samtidig
        }

        // Så vanlig navigasjon
        if (isAnimatingScroll || isScrollMode) return;
        
        if (e.key === 'ArrowDown') {
            if (currentSection < scrollSections.length - 1) {
                const nextSection = currentSection + 1;
                navigateToSection(nextSection);
                
            }
        } else if (e.key === 'ArrowUp') {
            if (currentSection > -1) {
                const prevSection = currentSection - 1;
                navigateToSection(prevSection);
                
            }
        }
    });
}

function setupControls() {
    const scrollModeBtn = document.getElementById('scroll-mode-btn');
    const resetBtn = document.getElementById('reset-btn');

    scrollModeBtn.addEventListener('click', () => {
        if (isScrollMode) {
            exitScrollMode();
        } else {
            enterScrollMode();
        }
    });

    resetBtn.addEventListener('click', () => {
        resetToStart();
        updateProgressBar();
    });
}
        function enterScrollMode() {
            isScrollMode = true;
            document.body.classList.add('scroll-mode');
            document.getElementById('scroll-mode-btn').textContent = 'Piltast Modus';
            document.getElementById('scroll-mode-btn').classList.add('active');
            document.getElementById('navigation-hint').textContent = 'Bruk scrollhjulet for å navigere';
            
            // Synkroniser scroll progress med nåværende tilstand
            if (currentSection === -1) {
                // Hvis vi er i oppløst tilstand, map buildProgress til scroll position
                const oppløstProgress = 1 - transitionState.buildProgress; // 0 = fullt bygget, 1 = fullt oppløst
                targetScrollProgress = oppløstProgress * 0.5 / (scrollSections.length + 1); // Første halvdel av første seksjon
                currentScrollProgress = targetScrollProgress;
            } else {
                // Hvis vi er i en faktisk seksjon
                const sectionProgress = transitionState.progress;
                targetScrollProgress = (1 + currentSection + sectionProgress) / (scrollSections.length + 1);
                currentScrollProgress = targetScrollProgress;
            }
            
            // Scroll til riktig posisjon
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            window.scrollTo(0, targetScrollProgress * maxScroll);
            
            // Legg til scroll listener
            window.addEventListener('scroll', handleScroll);
        }

        function exitScrollMode() {
            isScrollMode = false;
            document.body.classList.remove('scroll-mode');
            document.getElementById('scroll-mode-btn').textContent = 'Scroll Modus';
            document.getElementById('scroll-mode-btn').classList.remove('active');
            document.getElementById('navigation-hint').textContent = 'Bruk piltastene for å navigere';
            
            // Fjern scroll listener
            window.removeEventListener('scroll', handleScroll);
            
            // Bevar nåværende tilstand i stedet for å resette
            if (currentSection >= 0) {
                const section = scrollSections[currentSection];
                const targetX = section.offsetLeft + section.offsetWidth / 2 - window.innerWidth / 2;
                const targetY = section.offsetTop + section.offsetHeight / 2 - window.innerHeight / 2;
                window.scrollTo(targetX, targetY);
                currentStopIndex = currentSection;
            } else {
                // Hvis vi er i oppløst tilstand, gå til start layout
                const startSection = scrollSections[0];
                const initialX = startSection.offsetLeft + startSection.offsetWidth / 2 - window.innerWidth / 2;
                const initialY = startSection.offsetTop + startSection.offsetHeight / 2 - window.innerHeight / 2;
                window.scrollTo(initialX, initialY);
            }
        }

        function handleScroll() {
            if (!isScrollMode) return;
            
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            targetScrollProgress = Math.max(0, Math.min(1, scrollTop / maxScroll));
        }

        function updateScrollAnimation() {
            if (!isScrollMode) return;
            
            // Smooth dampening mot target scroll progress
            currentScrollProgress = lerp(currentScrollProgress, targetScrollProgress, SCROLL_DAMPENING);
            
            // Konverter dampened scroll progress til seksjon og intern progress
            const totalSections = scrollSections.length + 1; // +1 for oppløst tilstand
            const adjustedProgress = currentScrollProgress * totalSections;
            
            if (adjustedProgress <= 1) {
                // I oppløst tilstand eller overgang til første seksjon
                if (adjustedProgress <= 0.5) {
                    // Fullt oppløst tilstand (seksjon -1)
                    currentSection = -1;
                    transitionState.buildProgress = 0.0;
                    transitionState.progress = 1.0;
                    fromIndex = 0;
                    toIndex = 0;
                } else {
                    // Overgang fra oppløst til første seksjon
                    currentSection = 0;
                    fromIndex = 0;
                    toIndex = 0;
                    transitionState.progress = 1.0;
                    // BuildProgress går fra 0 til 1 når vi går fra oppløst til første seksjon
                    transitionState.buildProgress = (adjustedProgress - 0.5) * 2; // Mapper 0.5-1.0 til 0-1
                }
            } else {
                // I en av bildeseksjonene (1 til N)
                const sectionIndex = Math.floor(adjustedProgress - 1);
                const sectionProgress = (adjustedProgress - 1) % 1;
                
                currentSection = Math.min(sectionIndex, scrollSections.length - 1);
                
                if (sectionIndex < scrollSections.length - 1) {
                    // Overgang mellom to seksjoner
                    fromIndex = sectionIndex;
                    toIndex = sectionIndex + 1;
                    transitionState.progress = sectionProgress;
                    transitionState.buildProgress = 1.0;
                } else {
                    // Siste seksjon
                    fromIndex = scrollSections.length - 1;
                    toIndex = scrollSections.length - 1;
                    transitionState.progress = 1.0;
                    transitionState.buildProgress = 1.0;
                }
            }
        }

        function navigateToSection(targetSection) {
    if (targetSection < 0 || targetSection >= scrollSections.length) return; // Endret fra -1 til 0

    // Oppdater progress bar med en gang vi starter navigasjonen
    currentSection = targetSection;
    updateProgressBar();
    
    isAnimatingScroll = true;
    
    const section = scrollSections[targetSection];
    const targetX = section.offsetLeft + section.offsetWidth / 2 - window.innerWidth / 2;
    const targetY = section.offsetTop + section.offsetHeight / 2 - window.innerHeight / 2;
    
    fromIndex = currentStopIndex;
    toIndex = targetSection;
    
    const ease = "power2.inOut";

    const tl = gsap.timeline({
        onComplete: () => {
            isAnimatingScroll = false;
            currentStopIndex = targetSection;
        }
    });

    tl.to(window, { scrollTo: { x: targetX, y: targetY }, duration: TRANSITION_DURATION, ease: ease }, 0);
    
    transitionState.progress = 0;
    tl.to(transitionState, { progress: 1.0, duration: TRANSITION_DURATION, ease: ease }, 0);
    tl.to(transitionState, { buildProgress: 1.0, duration: TRANSITION_DURATION, ease: ease }, 0);
}

        function resetToStart() {
            updateProgressBar();
            if (isScrollMode) {
                window.scrollTo(0, 0);
                targetScrollProgress = 0;
                currentScrollProgress = 0;
            } else {
                // Reset til oppløst tilstand (seksjon -1)
                currentSection = -1;
                transitionState.buildProgress = 0.0;
                transitionState.progress = 1.0;
                currentStopIndex = 0;
                fromIndex = 0;
                toIndex = 0;
                
                const startSection = scrollSections[0];
                const initialX = startSection.offsetLeft + startSection.offsetWidth / 2 - window.innerWidth / 2;
                const initialY = startSection.offsetTop + startSection.offsetHeight / 2 - window.innerHeight / 2;
                window.scrollTo(initialX, initialY);
            }
        }
        
        function createGeometry() {
            imageGeometry = new THREE.BufferGeometry();
            imageGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(imageParticlesData.length * 3), 3));
            imageGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(imageParticlesData.length * 3), 3));
            imagePoints = new THREE.Points(imageGeometry, new THREE.PointsMaterial({ size: settings.PARTICLE_SIZE, vertexColors: true, sizeAttenuation: false }));
            scene.add(imagePoints);
            
            if (textParticlesData.length > 0) {
                textGeometry = new THREE.BufferGeometry();
                textGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(textParticlesData.length * 3), 3));
                textGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(textParticlesData.length * 3), 3));
                textPoints = new THREE.Points(textGeometry, new THREE.PointsMaterial({ size: settings.TEXT_PARTICLE_SIZE, vertexColors: true, sizeAttenuation: false }));
                scene.add(textPoints);
            }
        }

        const getRefPos = (ref) => {
            const rect = ref.getBoundingClientRect();
            return { x: rect.left + rect.width / 2 - window.innerWidth / 2, y: -(rect.top + rect.height / 2) + window.innerHeight / 2 };
        };

        function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();
    
    // Oppdater scroll animasjon med dampening
    updateScrollAnimation();
    
    // Oppdater progress bar kontinuerlig i scroll mode
    if (isScrollMode) {
        updateProgressBar();
    }
    
    const localProgress = transitionState.progress;
    const buildProgress = transitionState.buildProgress;
    

            const sectionText = currentSection === -1 ? "Oppløst" : `Seksjon ${currentSection + 1}`;
            const modeText = isScrollMode ? "Scroll Modus" : "Piltast Modus";
            document.getElementById('progress-indicator').textContent = `${sectionText} | Build: ${(buildProgress * 100).toFixed(0)}% | ${modeText}`;

            if (isScrollMode) {
    
}
            
            const currentChaosStrength = lerp(settings.BUILD_CHAOS_STRENGTH, settings.TRANSITION_CHAOS_STRENGTH, easeOutQuart(buildProgress));
            
            let avgY = 0;
            let totalParticles = 0;

            const imageStartRef = getRefPos(imageRefs[fromIndex]);
            const imageEndRef = getRefPos(imageRefs[toIndex]);
            
            const imagePositions = imageGeometry.attributes.position.array;
            const imageColors = imageGeometry.attributes.color.array;
            for (let i = 0; i < imageParticlesData.length; i++) {
                const p = imageParticlesData[i];
                const finalState = updateParticle(p, localProgress, buildProgress, currentChaosStrength, time, imageStartRef, imageEndRef, p.relativeX, p.relativeY, fromIndex, toIndex, p.colors);
                finalState.pos.toArray(imagePositions, i * 3);
                finalState.color.toArray(imageColors, i * 3);
                avgY += finalState.pos.y;
            }
            totalParticles += imageParticlesData.length;
            imageGeometry.attributes.position.needsUpdate = true;
            imageGeometry.attributes.color.needsUpdate = true;
            
            if (textParticlesData.length > 0) {
                const textStartRef = getRefPos(textRefs[fromIndex]);
                const textEndRef = getRefPos(textRefs[toIndex]);
                const textPositions = textGeometry.attributes.position.array;
                const textColors = textGeometry.attributes.color.array;
                for (let i = 0; i < textParticlesData.length; i++) {
                    const p = textParticlesData[i];
                    const rStartX = p.relativePositions[fromIndex]?.x || 0;
                    const rStartY = p.relativePositions[fromIndex]?.y || 0;
                    const rEndX = p.relativePositions[toIndex]?.x || 0;
                    const rEndY = p.relativePositions[toIndex]?.y || 0;
                    const rX = lerp(rStartX, rEndX, easeInOutCubic(localProgress));
                    const rY = lerp(rStartY, rEndY, easeInOutCubic(localProgress));
                    
                    const fromColor = p.colors[fromIndex];
                    const toColor = p.colors[toIndex];
                    const finalTextColor = fromColor.clone().lerp(toColor, easeInOutCubic(localProgress));
                    
                    const finalState = updateParticle(p, localProgress, buildProgress, currentChaosStrength/2, time, textStartRef, textEndRef, rX, rY, fromIndex, toIndex, null, finalTextColor);
                    finalState.pos.toArray(textPositions, i * 3);
                    finalState.color.toArray(textColors, i * 3);
                    avgY += finalState.pos.y;
                }
                totalParticles += textParticlesData.length;
                textGeometry.attributes.position.needsUpdate = true;
                textGeometry.attributes.color.needsUpdate = true;
            }
            
            if (totalParticles > 0) avgY /= totalParticles;

            if (!isNaN(avgY)) {
                camera.position.y = lerp(camera.position.y, avgY, settings.CAMERA_SMOOTHING);
            }
            
            renderer.render(scene, camera);
        }

        function updateParticle(p, localProgress, buildProgress, chaosStrength, time, startRef, endRef, relativeX, relativeY, fromIdx, toIdx, colors, overrideColor = null) {
            const personalBuildProgress = easeOutQuart(Math.max(0, Math.min(1, (buildProgress - p.normalizedY * settings.BUILD_WAVE_DELAY) / (1 - settings.BUILD_WAVE_DELAY || 1))));
            const transitionDelay = p.normalizedY * settings.TRANSITION_WAVE_DELAY + p.randomOffset * 0.15;
            const personalTransitionProgress = easeInOutCubic(Math.max(0, Math.min(1, (localProgress - transitionDelay) / (1 - transitionDelay || 1))));
            
            const anchorX = lerp(startRef.x, endRef.x, personalTransitionProgress) + relativeX;
            const anchorY = lerp(startRef.y, endRef.y, personalTransitionProgress) + relativeY;

            let finalColor;
            if (overrideColor) {
                finalColor = overrideColor;
            } else {
                finalColor = colors[fromIdx].clone().lerp(colors[toIdx], personalTransitionProgress);
            }

            const transitionChaos = Math.sin(personalTransitionProgress * Math.PI);
            const buildChaos = 1 - personalBuildProgress;
            const chaosFactor = buildChaos + transitionChaos * 0.8;
            
            const buildOffsetY = settings.BUILD_START_DISTANCE * (1 - personalBuildProgress);
            const ambientX = Math.cos(p.ambientAngle + time * p.ambientSpeed) * settings.AMBIENT_STRENGTH;
            const ambientY = Math.sin(p.ambientAngle + time * p.ambientSpeed) * settings.AMBIENT_STRENGTH;
            
            const finalPos = new THREE.Vector3(
                anchorX + (p.chaosOffsetX * chaosStrength + ambientX) * chaosFactor,
                anchorY + buildOffsetY + (p.chaosOffsetY * chaosStrength + ambientY) * chaosFactor,
                (p.chaosOffsetZ * chaosStrength) * chaosFactor
            );
            
            return { pos: finalPos, color: finalColor };
        }
        
        setup().catch(err => console.error("Feil ved oppsett:", err));
        
    </script>
</body>
</html>