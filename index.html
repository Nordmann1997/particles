<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <title>Partikkel-Portfolio med Dynamisk Layout</title>
    <style>
        body { 
            margin: 0; 
            background-color: #000; 
            color: #fff; 
            font-family: 'Helvetica Neue', sans-serif; 
            overflow: hidden; 
            visibility: hidden;
        }
        canvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            z-index: 1; 
            pointer-events: none; 
        }
        
        #content-container {
            position: relative;
            z-index: 2;
            width: 500vw;
            height: 500vh;
        }
        
        .scroll-section {
            position: absolute;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .text-reference, .image-reference {
            position: absolute;
            opacity: 0; 
            pointer-events: none;
        }
        
        #image-ref-1 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-1  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }

        #image-ref-2 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
        #text-ref-2  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-3 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-3  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-4 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
        #text-ref-4  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-5 { top: 50%; left: 30%; transform: translate(-50%, -50%); }
        #text-ref-5  { top: 50%; left: 70%; transform: translate(-50%, -50%); width: 450px; }
        
        #image-ref-6 { top: 50%; left: 70%; transform: translate(-50%, -50%); }
        #text-ref-6  { top: 50%; left: 30%; transform: translate(-50%, -50%); width: 450px; }

        #progress-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: #fff;
            font-size: 14px;
            opacity: 0.8;
            background-color: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #autoscroll-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background-color: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s;
        }

        .control-btn:hover {
            background-color: rgba(255,255,255,0.3);
        }

        .control-btn.active {
            background-color: rgba(255,255,255,0.4);
        }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>
    <div id="progress-indicator"></div>
    <div id="autoscroll-controls">
        <button class="control-btn" id="autoscroll-btn">Start Autoscroll</button>
        <button class="control-btn" id="reset-btn">Reset</button>
    </div>
    
    <div id="content-container">
        <div class="scroll-section"><div id="image-ref-1" class="image-reference"></div><div id="text-ref-1" class="text-reference"></div></div>
        <div class="scroll-section"><div id="image-ref-2" class="image-reference"></div><div id="text-ref-2" class="text-reference"></div></div>
        <div class="scroll-section"><div id="image-ref-3" class="image-reference"></div><div id="text-ref-3" class="text-reference"></div></div>
        <div class="scroll-section"><div id="image-ref-4" class="image-reference"></div><div id="text-ref-4" class="text-reference"></div></div>
        <div class="scroll-section"><div id="image-ref-5" class="image-reference"></div><div id="text-ref-5" class="text-reference"></div></div>
        <div class="scroll-section"><div id="image-ref-6" class="image-reference"></div><div id="text-ref-6" class="text-reference"></div></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollToPlugin.min.js"></script>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.156.1/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- INNSTILLINGER ---
        const settings = {
            IMAGE_URLS: [ 
                'https://jwk.no/bubbles%202/pictures/index/ludo.jpg', 
                'https://jwk.no/bubbles%202/pictures/index/stolen.jpg',
                'https://jwk.no/bubbles%202/pictures/index/oval.jpg',
                'https://jwk.no/bubbles%202/pictures/index/front_without.jpg',
                'https://jwk.no/bubbles%202/pictures/index/dorhondtak.jpg',
                'https://jwk.no/bubbles%202/pictures/index/benk.jpg'
            ],
            TEXTS: [
                { text: "Velkommen til min portefølje\nTrykk Start Autoscroll eller bruk piltastene", fontSize: 40, color: '#ffffff' },
                { text: "Hvert design er bygget opp\nav tusenvis av lyspunkt", fontSize: 32, color: '#ffffff' },
                { text: "Form og farge flyter over\ni en sømløs overgang", fontSize: 32, color: '#ffffff' },
                { text: "Teksten følger den samme\nreisen som bildene", fontSize: 32, color: '#ffffff' },
                { text: "Drevet av Three.js\nog en custom partikkelmotor", fontSize: 32, color: '#ffffff' },
                { text: "Takk for at du tok deg tid\ntil å se på prosjektet", fontSize: 32, color: '#ffffff' }
            ],
            MAX_DIMENSION: 400, PARTICLE_SIZE: 0.8, TEXT_PARTICLE_SIZE: 1.5,
            CAMERA_SMOOTHING: 0.08,
            BUILD_WAVE_DELAY: 0.4, BUILD_START_DISTANCE: 200, TRANSITION_WAVE_DELAY: 0.2,
            BUILD_CHAOS_STRENGTH: 5000, TRANSITION_CHAOS_STRENGTH: 800,
            AMBIENT_STRENGTH: 10, AMBIENT_SPEED: 0.0015,
        };

        gsap.registerPlugin(ScrollToPlugin);
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(window.innerWidth/-2, window.innerWidth/2, window.innerHeight/2, window.innerHeight/-2, 1, 10000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('particle-canvas'), alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        let imageParticlesData = [], textParticlesData = [];
        let imageGeometry, textGeometry, imagePoints, textPoints;
        let imageRefs = [], textRefs = [], scrollSections = [];
        let clock = new THREE.Clock();

        let currentStopIndex = 0;
        let isAnimatingScroll = false;
        let isAutoScrolling = false;
        let autoScrollInterval = null;
        
        // NYTT: Bruker -1 for å indikere oppløst tilstand (seksjon 1)
        let currentSection = -1; // -1 = oppløst, 0 = første bilde/tekst, 1 = andre bilde/tekst, osv.
        
        let transitionState = { progress: 0.0, buildProgress: 0.0 }; 
        let fromIndex = 0;
        let toIndex = 0;
        
        const TRANSITION_DURATION = 5.0;
        const AUTOSCROLL_DELAY = 1000;

        const lerp = (a, b, t) => a + (b - a) * t;
        const easeOutQuart = t => 1 - Math.pow(1 - t, 4);
        const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

        function getTextPixelData(text, fontSize, color) {
            const dpr = window.devicePixelRatio || 3;
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            ctx.font = `bold ${fontSize * dpr}px 'Helvetica Neue', sans-serif`;
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.2 * dpr;
            const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
            canvas.width = maxWidth + 20 * dpr; canvas.height = lines.length * lineHeight + 20 * dpr;
            ctx.fillStyle = color; ctx.font = `bold ${fontSize * dpr}px 'Helvetica Neue', sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            lines.forEach((line, i) => ctx.fillText(line, canvas.width/2, (canvas.height/2) + (i - (lines.length-1)/2)*lineHeight));
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data;
            const pixels = [];
            let minY = Infinity, maxY = -Infinity;
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    if (data[(y * canvas.width + x) * 4 + 3] > 200) {
                        const rY = -y/dpr + (canvas.height/2/dpr);
                        if (rY < minY) minY = rY; if (rY > maxY) maxY = rY;
                        pixels.push({ x: x/dpr - canvas.width/2/dpr, y: rY, normalizedY: 0 });
                    }
                }
            }
            pixels.forEach(p => { p.normalizedY = (p.y - minY) / (maxY - minY || 1); });
            return pixels;
        }
        
        const createRandomOffsets = () => ({
             randomOffset: Math.random(), chaosOffsetX: (Math.random()-0.5), chaosOffsetY: (Math.random()-0.5), chaosOffsetZ: (Math.random()-0.5),
            ambientAngle: Math.random()*Math.PI*2, ambientSpeed: settings.AMBIENT_SPEED*(0.5+Math.random()*0.5)
        });

        async function setup() {
            document.querySelectorAll('.image-reference').forEach(el => imageRefs.push(el));
            document.querySelectorAll('.text-reference').forEach(el => textRefs.push(el));
            scrollSections = Array.from(document.querySelectorAll('.scroll-section'));

            const contentContainer = document.getElementById('content-container');
            const containerW = contentContainer.offsetWidth - window.innerWidth;
            const containerH = contentContainer.offsetHeight - window.innerHeight;
            let positions = [];
            const startX = containerW / 2;
            const startY = 0;
            positions.push({ x: startX, y: startY });
            const minDistance = window.innerWidth * 0.8; 
            for (let i = 1; i < scrollSections.length; i++) {
                let newPos;
                let attempts = 0;
                do {
                    newPos = { x: Math.random() * containerW, y: Math.random() * containerH };
                    attempts++;
                } while (positions.some(p => Math.hypot(p.x - newPos.x, p.y - newPos.y) < minDistance) && attempts < 50);
                positions.push(newPos);
            }
            scrollSections.forEach((section, index) => {
                section.style.left = `${positions[index].x}px`;
                section.style.top = `${positions[index].y}px`;
            });
            
            const textures = await Promise.all(settings.IMAGE_URLS.map(url => new THREE.TextureLoader().loadAsync(url)));
            textures.forEach(t => t.colorSpace = THREE.SRGBColorSpace);
            const ratio = textures[0].image.naturalWidth / textures[0].image.naturalHeight;
            const displayW = settings.MAX_DIMENSION; const displayH = settings.MAX_DIMENSION / ratio;
            imageRefs.forEach(ref => { ref.style.width = `${displayW}px`; ref.style.height = `${displayH}px`; });
            textRefs.forEach(ref => { ref.style.width = '450px'; ref.style.height = `${displayH}px`; }); 
            
            const allImageData = textures.map(tex => {
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                canvas.width = displayW; canvas.height = displayH;
                ctx.drawImage(tex.image, 0, 0, displayW, displayH);
                return ctx.getImageData(0, 0, displayW, displayH).data;
            });
            let particlePresence = new Uint8Array(displayW * displayH).fill(0);
            allImageData.forEach(data => { for (let i = 0; i < data.length; i += 4) if (data[i + 3] > 128) particlePresence[i / 4] = 1; });
            let imgMinY = Infinity, imgMaxY = -Infinity;
            for (let y = 0; y < displayH; y++) {
                for (let x = 0; x < displayW; x++) {
                    if (particlePresence[y * displayW + x]) {
                        const rY = -y + displayH / 2;
                        if (rY < imgMinY) imgMinY = rY; if (rY > imgMaxY) imgMaxY = rY;
                        imageParticlesData.push({
                            relativeX: x - displayW / 2, relativeY: rY,
                            colors: allImageData.map(data => new THREE.Color(data[(y*displayW+x)*4]/255, data[(y*displayW+x)*4+1]/255, data[(y*displayW+x)*4+2]/255).convertSRGBToLinear()),
                            normalizedY: 0, ...createRandomOffsets()
                        });
                    }
                }
            }
            imageParticlesData.forEach(p => { p.normalizedY = (p.relativeY - imgMinY) / (imgMaxY - imgMinY || 1); });
            
            const allTextPixels = settings.TEXTS.map(t => getTextPixelData(t.text, t.fontSize, t.color));
            const maxTextParticles = Math.max(0, ...allTextPixels.map(p => p.length));
            
            if (maxTextParticles > 0) {
                for (let i = 0; i < maxTextParticles; i++) {
                    textParticlesData.push({
                        relativePositions: allTextPixels.map(pixels => {
                            if (pixels.length === 0) return { x: 0, y: 0, normalizedY: 0.5 };
                            return pixels[i % pixels.length];
                        }),
                        colors: settings.TEXTS.map(text => new THREE.Color(text.color).convertSRGBToLinear()),
                        normalizedY: allTextPixels[0].length > 0 ? (allTextPixels[0][i % allTextPixels[0].length]?.normalizedY || 0.5) : 0.5,
                        ...createRandomOffsets()
                    });
                }
            }

            createGeometry();
            setupNavigation();
            setupAutoScroll();
            
            // Start med oppløste partikler (seksjon -1)
            currentSection = -1;
            fromIndex = 0;
            toIndex = 0;
            transitionState.progress = 1.0;
            transitionState.buildProgress = 0.0;
            
            const startSection = scrollSections[0];
            const initialX = startSection.offsetLeft + startSection.offsetWidth / 2 - window.innerWidth / 2;
            const initialY = startSection.offsetTop + startSection.offsetHeight / 2 - window.innerHeight / 2;
            window.scrollTo(initialX, initialY);
            
            requestAnimationFrame(() => {
                animate(); 
                document.body.style.visibility = 'visible';
            });
        }
        
        function setupNavigation() {
             window.addEventListener('keydown', (e) => {
                if (isAnimatingScroll) return;
                
                if (isAutoScrolling) {
                    stopAutoScroll();
                }
                
                if (e.key === 'ArrowDown') {
                    if (currentSection < scrollSections.length - 1) {
                        const nextSection = currentSection + 1;
                        navigateToSection(nextSection);
                    }
                } else if (e.key === 'ArrowUp') {
                    if (currentSection > -1) {
                        const prevSection = currentSection - 1;
                        navigateToSection(prevSection);
                    }
                }
            });
        }

        function setupAutoScroll() {
            const autoscrollBtn = document.getElementById('autoscroll-btn');
            const resetBtn = document.getElementById('reset-btn');

            autoscrollBtn.addEventListener('click', () => {
                if (isAutoScrolling) {
                    stopAutoScroll();
                } else {
                    startAutoScroll();
                }
            });

            resetBtn.addEventListener('click', () => {
                resetToStart();
            });
        }

        function startAutoScroll() {
            if (isAnimatingScroll) return;
            
            isAutoScrolling = true;
            document.getElementById('autoscroll-btn').textContent = 'Stopp Autoscroll';
            document.getElementById('autoscroll-btn').classList.add('active');
            
            // Start autoscroll med riktig delay
            autoScrollInterval = setTimeout(() => {
                autoScrollNext();
            }, AUTOSCROLL_DELAY);
        }

        function stopAutoScroll() {
            if (!isAutoScrolling) return;
            
            isAutoScrolling = false;
            if (autoScrollInterval) {
                clearTimeout(autoScrollInterval);
                autoScrollInterval = null;
            }
            
            document.getElementById('autoscroll-btn').textContent = 'Start Autoscroll';
            document.getElementById('autoscroll-btn').classList.remove('active');
        }

        function autoScrollNext() {
            if (!isAutoScrolling) return;
            
            // Gå til neste seksjon, eller tilbake til start
            const nextSection = currentSection < scrollSections.length - 1 ? currentSection + 1 : -1;
            navigateToSection(nextSection);
            
            // Sett opp neste autoscroll
            autoScrollInterval = setTimeout(() => {
                autoScrollNext();
            }, AUTOSCROLL_DELAY);
        }

        function resetToStart() {
            stopAutoScroll();
            
            // Reset til oppløst tilstand (seksjon -1)
            currentSection = -1;
            transitionState.buildProgress = 0.0;
            transitionState.progress = 1.0;
            currentStopIndex = 0;
            fromIndex = 0;
            toIndex = 0;
            
            const startSection = scrollSections[0];
            const initialX = startSection.offsetLeft + startSection.offsetWidth / 2 - window.innerWidth / 2;
            const initialY = startSection.offsetTop + startSection.offsetHeight / 2 - window.innerHeight / 2;
            window.scrollTo(initialX, initialY);
        }

        function navigateToSection(targetSection) {
            if (targetSection < -1 || targetSection >= scrollSections.length) return;

            isAnimatingScroll = true;
            
            if (targetSection === -1) {
                // Gå tilbake til oppløst tilstand
                const tl = gsap.timeline({
                    onComplete: () => {
                        isAnimatingScroll = false;
                        currentSection = -1;
                    }
                });
                
                tl.to(transitionState, { 
                    buildProgress: 0.0, 
                    duration: TRANSITION_DURATION, 
                    ease: "power3.inOut" 
                });
                
            } else {
                // Gå til et bilde/tekst
                const section = scrollSections[targetSection];
                const targetX = section.offsetLeft + section.offsetWidth / 2 - window.innerWidth / 2;
                const targetY = section.offsetTop + section.offsetHeight / 2 - window.innerHeight / 2;
                
                fromIndex = currentStopIndex;
                toIndex = targetSection;
                
                const ease = "power3.inOut";

                const tl = gsap.timeline({
                    onComplete: () => {
                        isAnimatingScroll = false;
                        currentSection = targetSection;
                        currentStopIndex = targetSection;
                    }
                });

                tl.to(window, { scrollTo: { x: targetX, y: targetY }, duration: TRANSITION_DURATION, ease: ease }, 0);
                
                transitionState.progress = 0;
                tl.to(transitionState, { progress: 1.0, duration: TRANSITION_DURATION, ease: ease }, 0);
                tl.to(transitionState, { buildProgress: 1.0, duration: TRANSITION_DURATION, ease: ease }, 0);
            }
        }

        // Bakoverkompatibilitet
        function navigateTo(stopIndex) {
            navigateToSection(stopIndex);
        }
        
        function createGeometry() {
            imageGeometry = new THREE.BufferGeometry();
            imageGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(imageParticlesData.length * 3), 3));
            imageGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(imageParticlesData.length * 3), 3));
            imagePoints = new THREE.Points(imageGeometry, new THREE.PointsMaterial({ size: settings.PARTICLE_SIZE, vertexColors: true, sizeAttenuation: false }));
            scene.add(imagePoints);
            
            if (textParticlesData.length > 0) {
                textGeometry = new THREE.BufferGeometry();
                textGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(textParticlesData.length * 3), 3));
                textGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(textParticlesData.length * 3), 3));
                textPoints = new THREE.Points(textGeometry, new THREE.PointsMaterial({ size: settings.TEXT_PARTICLE_SIZE, vertexColors: true, sizeAttenuation: false }));
                scene.add(textPoints);
            }
        }

        const getRefPos = (ref) => {
            const rect = ref.getBoundingClientRect();
            return { x: rect.left + rect.width / 2 - window.innerWidth / 2, y: -(rect.top + rect.height / 2) + window.innerHeight / 2 };
        };

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            const localProgress = transitionState.progress;
            const buildProgress = transitionState.buildProgress;

            const sectionText = currentSection === -1 ? "Oppløst" : `Seksjon ${currentSection + 1}`;
            document.getElementById('progress-indicator').textContent = `${sectionText} | Build: ${(buildProgress * 100).toFixed(0)}% ${isAutoScrolling ? '| AutoScroll: ON' : ''}`;
            
            const currentChaosStrength = lerp(settings.BUILD_CHAOS_STRENGTH, settings.TRANSITION_CHAOS_STRENGTH, easeOutQuart(buildProgress));
            
            let avgY = 0;
            let totalParticles = 0;

            const imageStartRef = getRefPos(imageRefs[fromIndex]);
            const imageEndRef = getRefPos(imageRefs[toIndex]);
            
            const imagePositions = imageGeometry.attributes.position.array;
            const imageColors = imageGeometry.attributes.color.array;
            for (let i = 0; i < imageParticlesData.length; i++) {
                const p = imageParticlesData[i];
                const finalState = updateParticle(p, localProgress, buildProgress, currentChaosStrength, time, imageStartRef, imageEndRef, p.relativeX, p.relativeY, fromIndex, toIndex, p.colors);
                finalState.pos.toArray(imagePositions, i * 3);
                finalState.color.toArray(imageColors, i * 3);
                avgY += finalState.pos.y;
            }
            totalParticles += imageParticlesData.length;
            imageGeometry.attributes.position.needsUpdate = true;
            imageGeometry.attributes.color.needsUpdate = true;
            
            if (textParticlesData.length > 0) {
                const textStartRef = getRefPos(textRefs[fromIndex]);
                const textEndRef = getRefPos(textRefs[toIndex]);
                const textPositions = textGeometry.attributes.position.array;
                const textColors = textGeometry.attributes.color.array;
                for (let i = 0; i < textParticlesData.length; i++) {
                    const p = textParticlesData[i];
                    const rStartX = p.relativePositions[fromIndex]?.x || 0;
                    const rStartY = p.relativePositions[fromIndex]?.y || 0;
                    const rEndX = p.relativePositions[toIndex]?.x || 0;
                    const rEndY = p.relativePositions[toIndex]?.y || 0;
                    const rX = lerp(rStartX, rEndX, easeInOutCubic(localProgress));
                    const rY = lerp(rStartY, rEndY, easeInOutCubic(localProgress));
                    
                    const fromColor = p.colors[fromIndex];
                    const toColor = p.colors[toIndex];
                    const finalTextColor = fromColor.clone().lerp(toColor, easeInOutCubic(localProgress));
                    
                    const finalState = updateParticle(p, localProgress, buildProgress, currentChaosStrength/2, time, textStartRef, textEndRef, rX, rY, fromIndex, toIndex, null, finalTextColor);
                    finalState.pos.toArray(textPositions, i * 3);
                    finalState.color.toArray(textColors, i * 3);
                    avgY += finalState.pos.y;
                }
                totalParticles += textParticlesData.length;
                textGeometry.attributes.position.needsUpdate = true;
                textGeometry.attributes.color.needsUpdate = true;
            }
            
            if (totalParticles > 0) avgY /= totalParticles;

            if (!isNaN(avgY)) {
                camera.position.y = lerp(camera.position.y, avgY, settings.CAMERA_SMOOTHING);
            }
            
            renderer.render(scene, camera);
        }

        function updateParticle(p, localProgress, buildProgress, chaosStrength, time, startRef, endRef, relativeX, relativeY, fromIdx, toIdx, colors, overrideColor = null) {
            const personalBuildProgress = easeOutQuart(Math.max(0, Math.min(1, (buildProgress - p.normalizedY * settings.BUILD_WAVE_DELAY) / (1 - settings.BUILD_WAVE_DELAY || 1))));
            const transitionDelay = p.normalizedY * settings.TRANSITION_WAVE_DELAY + p.randomOffset * 0.15;
            const personalTransitionProgress = easeInOutCubic(Math.max(0, Math.min(1, (localProgress - transitionDelay) / (1 - transitionDelay || 1))));
            
            const anchorX = lerp(startRef.x, endRef.x, personalTransitionProgress) + relativeX;
            const anchorY = lerp(startRef.y, endRef.y, personalTransitionProgress) + relativeY;

            let finalColor;
            if (overrideColor) {
                finalColor = overrideColor;
            } else {
                finalColor = colors[fromIdx].clone().lerp(colors[toIdx], personalTransitionProgress);
            }

            const transitionChaos = Math.sin(personalTransitionProgress * Math.PI);
            const buildChaos = 1 - personalBuildProgress;
            const chaosFactor = buildChaos + transitionChaos * 0.8;
            
            const buildOffsetY = settings.BUILD_START_DISTANCE * (1 - personalBuildProgress);
            const ambientX = Math.cos(p.ambientAngle + time * p.ambientSpeed) * settings.AMBIENT_STRENGTH;
            const ambientY = Math.sin(p.ambientAngle + time * p.ambientSpeed) * settings.AMBIENT_STRENGTH;
            
            const finalPos = new THREE.Vector3(
                anchorX + (p.chaosOffsetX * chaosStrength + ambientX) * chaosFactor,
                anchorY + buildOffsetY + (p.chaosOffsetY * chaosStrength + ambientY) * chaosFactor,
                (p.chaosOffsetZ * chaosStrength) * chaosFactor
            );
            
            return { pos: finalPos, color: finalColor };
        }
        
        setup().catch(err => console.error("Feil ved oppsett:", err));
        window.addEventListener('resize', () => { window.location.reload(); });
    </script>
</body>
</html>
